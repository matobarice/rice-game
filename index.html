<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ササニシキ・ドライブ：精米機で人類を救え</title>
<style>
  html,body{margin:0;background:#0e0f13;color:#e9edf1;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:12px}
  /* スマホで横幅フィット（内部解像度は800x560のまま） */
  canvas{background:#12151b;border:1px solid #2a2f3a;border-radius:8px;touch-action:none;width:100%;max-width:900px;height:auto}
  .hint{opacity:.85;font-size:14px}

  /* X共有ボタン */
  .share-btn{
    position: fixed; right: 12px; bottom: 14px;
    font: 16px system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    padding: 10px 14px; border-radius: 999px;
    border: 1px solid #2a2f3a; background:#1b2130; color:#e9edf1;
    box-shadow: 0 4px 14px rgba(0,0,0,.25);
    display: none; z-index: 10;
  }
  .share-btn:active{ transform: translateY(1px); }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="800" height="560"></canvas>
  <button id="shareBtn" class="share-btn" type="button">結果をXにポスト</button>
  <div class="hint" id="hint">
    操作：指でドラッグ＝移動 / 画面タップ＝スタート・リトライ（PCは←→↑↓/WASD・スペース）
  </div>
</div>
<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const shareBtn = document.getElementById('shareBtn');

  const W = cvs.width, H = cvs.height;
  const STATE = { TITLE:0, PLAY:1, GAMEOVER:2 };
  let state = STATE.TITLE;

  // ====== 入力（キーボード＋タッチ） ======
  const key = {};
  addEventListener('keydown', e => { key[e.key.toLowerCase()] = true; if(e.key===' ') e.preventDefault(); });
  addEventListener('keyup',   e => { key[e.key.toLowerCase()] = false; });

  // タッチ（またはマウス）で指した場所に向かって進む
  let touchActive = false;
  let touchTarget = {x: W/2, y: H/2};

  function toCanvasXY(e){
    const r = cvs.getBoundingClientRect();
    const x = (e.clientX - r.left) * (cvs.width / r.width);
    const y = (e.clientY - r.top)  * (cvs.height/ r.height);
    return {x,y};
  }
  function startGameIfNeeded(){
    if (state !== STATE.PLAY){
      reset();
      state = STATE.PLAY;
      updateShareButton();
    }
  }
  // Pointerイベント（iPhone/Safari対応）
  cvs.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    startGameIfNeeded();
    touchActive = true;
    touchTarget = toCanvasXY(e);
    cvs.setPointerCapture(e.pointerId);
  }, {passive:false});
  cvs.addEventListener('pointermove', (e)=>{
    if(!touchActive) return;
    e.preventDefault();
    touchTarget = toCanvasXY(e);
  }, {passive:false});
  function endPointer(e){ if(!touchActive) return; touchActive = false; }
  cvs.addEventListener('pointerup',     endPointer, {passive:false});
  cvs.addEventListener('pointercancel', endPointer, {passive:false});
  cvs.addEventListener('pointerleave',  endPointer, {passive:false});

  // ランダム
  const rnd = (a,b) => Math.random()*(b-a)+a;

  // プレイヤー（精米機）
  const player = {
    x: W/2, y: H-90, vx:0, vy:0, spd: 4.0,
    size: 22,
    suctionR: 48,
    heat: 0, power: 100,
  };

  // ゲームデータ
  let grains = [], pests = [];
  let score = 0, best = 0, lives = 3, combo = 0, comboTimer = 0, tick = 0;
  let spawnGrainInterval = 36, spawnPestInterval = 220;

  function reset() {
    player.x=W/2; player.y=H-90; player.vx=player.vy=0;
    player.suctionR=48; player.heat=0; player.power=100;
    grains.length=0; pests.length=0;
    score=0; lives=3; combo=0; comboTimer=0; tick=0;
    spawnGrainInterval=36; spawnPestInterval=220;
    updateShareButton(); // プレイ前は非表示
  }

  function spawnGrain(){
    const x = rnd(30, W-30);
    const spd = rnd(1.1,2.2);
    grains.push({x, y:-20, vy: spd, r: 10, processed:false});
  }
  function spawnPest(){
    const x = Math.random()<.5 ? -20 : W+20;
    const vx = x<0 ? rnd(1.2,2.2) : rnd(-2.2,-1.2);
    const y = rnd(H*0.25, H*0.6);
    pests.push({x, y, vx, r: 14, t: 0});
  }
  const dist2 = (a,b,c,d)=> (a-c)*(a-c)+(b-d)*(b-d);

  function tryProcess(g){
    const r = player.suctionR;
    if (dist2(player.x, player.y, g.x, g.y) < r*r){
      const dx = player.x - g.x, dy = player.y - g.y;
      const d = Math.hypot(dx,dy)||1;
      g.x += dx/d * 2.5;
      g.y += dy/d * 2.5;
      if (d < player.size){
        g.processed=true;
        score += 10 + Math.floor(combo*1.5);
        combo += 1;
        comboTimer = 120;
        player.power = Math.max(0, player.power - 0.8);
        return true;
      }
    }
    return false;
  }

  function update() {
    tick++;

    // 入力処理
    const L=key['arrowleft']||key['a'], R=key['arrowright']||key['d'];
    const U=key['arrowup']||key['w'],   D=key['arrowdown']||key['s'];
    const spd = player.spd * (player.power>0 ? 1:0.6);

    if (touchActive){
      const dx = touchTarget.x - player.x;
      const dy = touchTarget.y - player.y;
      const d = Math.hypot(dx,dy);
      if (d > 2){ player.vx = (dx/d) * spd; player.vy = (dy/d) * spd; }
      else { player.vx *= 0.85; player.vy *= 0.85; }
    } else {
      if(L) player.vx = -spd; else if(R) player.vx = spd; else player.vx *= 0.85;
      if(U) player.vy = -spd; else if(D) player.vy = spd; else player.vy *= 0.85;
    }

    player.x += player.vx; player.y += player.vy;
    player.x = Math.max(24, Math.min(W-24, player.x));
    player.y = Math.max(80, Math.min(H-24, player.y));

    // スポーン
    if (tick % spawnGrainInterval === 0) spawnGrain();
    if (tick % spawnPestInterval === 0 && tick>240) spawnPest();

    // 籾
    for (let i=grains.length-1;i>=0;i--){
      const g=grains[i];
      g.y += g.vy;
      if (tryProcess(g)){ grains.splice(i,1); continue; }
      if (g.y > H+20){
        grains.splice(i,1);
        lives -= 1; combo = 0; comboTimer = 0;
      }
    }

    // 害虫
    for (let i=pests.length-1;i>=0;i--){
      const p=pests[i];
      p.x += p.vx; p.t++;
      if (dist2(p.x,p.y,player.x,player.y) < (p.r+player.size)*(p.r+player.size)){
        player.heat = Math.min(100, player.heat + 14);
        player.power = Math.max(0, player.power - 8);
        pests.splice(i,1);
        combo = 0; comboTimer=0;
        continue;
      }
      if (p.x < -40 || p.x > W+40) pests.splice(i,1);
    }

    // コンボ
    if (comboTimer>0) comboTimer--;
    if (comboTimer===0) combo=0;
    player.suctionR = 48 + Math.min(80, combo*3);

    // 温度・電力
    player.heat = Math.max(0, player.heat - 0.05);
    if (player.power<100 && (tick%30===0)) player.power += 1;

    // 難易度スケール
    if (tick%600===0){
      spawnGrainInterval = Math.max(16, spawnGrainInterval-2);
      spawnPestInterval  = Math.max(120, spawnPestInterval-10);
    }

    if (lives<=0 || player.heat>=100){
      state = STATE.GAMEOVER;
      best = Math.max(best, score);
      updateShareButton();
    }
  }

  function drawGauge(x,y,w,h,ratio,label,color){
    ctx.save();
    ctx.fillStyle="#1b2130"; ctx.fillRect(x,y,w,h);
    ctx.fillStyle=color; ctx.fillRect(x,y,w*ratio,h);
    ctx.strokeStyle="#2a2f3a"; ctx.strokeRect(x,y,w,h);
    ctx.fillStyle="#cfd7e5"; ctx.font="12px system-ui"; ctx.fillText(label, x+6, y+h-6);
    ctx.restore();
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    const grad = ctx.createLinearGradient(0,0,0,H);
    grad.addColorStop(0,"#0f1522"); grad.addColorStop(1,"#0b0e16");
    ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);

    ctx.fillStyle="#cfd7e5"; ctx.font="18px system-ui";
    ctx.fillText(`SCORE: ${score}`, 16, 28);
    ctx.fillText(`BEST: ${best}`, 200, 28);
    ctx.fillText(`LIVES: ${"🍚".repeat(Math.max(0,lives))}`, 360, 28);
    ctx.fillText(`COMBO: x${combo}`, 520, 28);

    drawGauge(W-280,10,120,16, player.power/100, "POWER", "#8fd0ff");
    drawGauge(W-140,10,120,16, player.heat/100,  "HEAT",  "#ff9c8f");

    // プレイヤー
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.beginPath(); ctx.arc(0,0, player.suctionR, 0, Math.PI*2);
    ctx.fillStyle="rgba(255,255,255,0.04)"; ctx.fill();

    ctx.fillStyle="#e7eef5"; ctx.fillRect(-20,-22,40,44);
    ctx.fillStyle="#b9c7d6"; ctx.fillRect(-16,-26,32,8);
    ctx.fillStyle="#a7c4f5"; ctx.fillRect(-14,-4,28,16);
    ctx.fillStyle="#d0d7df"; ctx.fillRect(-6,22,12,8);
    ctx.strokeStyle="#8894a8"; ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.stroke();
    ctx.restore();

    // 籾
    grains.forEach(g=>{
      ctx.beginPath(); ctx.arc(g.x,g.y,g.r,0,Math.PI*2);
      ctx.fillStyle="#c49b3a"; ctx.fill();
      ctx.strokeStyle="rgba(0,0,0,0.15)";
      ctx.beginPath(); ctx.moveTo(g.x-g.r/2,g.y); ctx.lineTo(g.x+g.r/2,g.y); ctx.stroke();
    });

    // 害虫
    pests.forEach(p=>{
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fillStyle="rgba(140,160,210,0.6)"; ctx.fill();
      ctx.strokeStyle="rgba(200,220,255,0.35)"; ctx.stroke();
    });

    // 状態画面
    if (state===STATE.TITLE){
      ctx.fillStyle="#e9edf1"; ctx.font="bold 32px system-ui";
      ctx.textAlign="center";
      ctx.fillText("ササニシキ・ドライブ", W/2, H/2-30);
      ctx.font="16px system-ui";
      ctx.fillText("精米機で人類を救え！", W/2, H/2);
      ctx.fillText("タップでスタート（PCはスペース）", W/2, H/2+36);
      ctx.textAlign="left";
    } else if (state===STATE.GAMEOVER){
      ctx.fillStyle="#e9edf1"; ctx.font="bold 30px system-ui";
      ctx.textAlign="center";
      ctx.fillText("GAME OVER", W/2, H/2-20);
      ctx.font="16px system-ui";
      ctx.fillText(`SCORE: ${score}  |  BEST: ${best}`, W/2, H/2+10);
      ctx.fillText("タップでリトライ（PCはスペース）", W/2, H/2+40);
      ctx.textAlign="left";
    }

    // 毎フレーム同期（安全策）
    updateShareButton();
  }

  // 共有ボタンの表示制御＆ポスト
  function updateShareButton(){
    if (state === STATE.GAMEOVER){
      shareBtn.style.display = 'inline-flex';
    } else {
      shareBtn.style.display = 'none';
    }
  }
  shareBtn.addEventListener('click', ()=>{
    const text = `【ササニシキ・ドライブ】スコア ${score} 点！#ササニシキ #精米機で人類を救え`;
    const url  = location.href;
    const intent = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
    window.open(intent, '_blank');
  });

  function loop(){ if (state===STATE.PLAY) update(); draw(); requestAnimationFrame(loop); }
  loop();

  // PC用：スペースで開始/再開も残す
  addEventListener('keydown', (e)=>{
    if (e.key === ' '){
      if (state!==STATE.PLAY){ reset(); state = STATE.PLAY; updateShareButton(); }
    }
  });

  reset();
})();
</script>
</body>
</html>
